package main

import (
	"fmt"
)

func main() {

	//注意，无缓冲区channel在读端和写段都准备就绪的时候不阻塞
	s1 := make(chan int)

	/**
	  主线程写入:
	      主Go程再写入数据时,但此时并没有读端准备就绪，因此代码会在该行阻塞哟~我们称之"死锁"
	      在开发中一定使用锁机制的时候一定要注意避免"死锁"现象哟~
	*/
	s1 <- 5

	/**
	  子线程读取:
	      通过上面的解释，相比大家心里也清楚，代码在上一行已经阻塞了,压根就没有机会执行到当前行,即没有开启子Go程.
	*/
	go func() {
		fmt.Println(<-s1)
	}()
}
