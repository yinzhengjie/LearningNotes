package main

import (
	"fmt"
)

func main() {
	/*
		int:
			默认是有符号(signed)整形，其宽度与操作系统有关，因此占用空间大小取决于操作系统设定数据的值，初始值为0。
		uint:
			无符号整形，前面的字符u表示无符号("unsigned"),即二进制最高位的符号位不在表示正负数了。
			其宽度与操作系统有关，因此占用空间大小取决于操作系统设定数据的值，初始值为0。

		温馨提示:
			(1)默认使用自动推导类型创建的整数均为int;
			(2)int和uint在内存中占的大小和操作系统相关，如下所示:
				1>.在32为操作系统下int相当于int32,uint相当于uint32
				2>.在64位操作系统下int相当于int64,uint相当于uint64
			(3)int和int64是不同的数据类型,操作时需要类型转换;
			(4)如果超出整数数据类型的表示范围我们称之为数据溢出,计算机处理的机制就是高位截断，只截取低位运算;
			(5)整数的补码才是在计算机中的存储形式,举个例子:
				var a int 8 = 127
				a = a + 2			//0111 1111 + 0000 0010 = 1000 0001
				fmt.Println(a)		//我们看到a是有符号int类型，由于计算机以补码的形式存储，因此输出结果为-127，

			关于原码反码补码的基础知识扫盲，博主推荐阅读:
				https://www.cnblogs.com/yinzhengjie/p/8666354.html
	*/
	a := -128 //表示int8的最小值
	b := 255  //表示uint8的最小值
	fmt.Printf("a的类型为:[%T],a的值为:[%d]\n", a, a)
	fmt.Printf("b的类型为:[%T],b的值为:[%d]\n", b, b)

	c := -32768 //表示int16的最小值
	d := 65535  //表示uint16的最大值
	fmt.Printf("c的类型为:[%T],c的值为:[%d]\n", c, c)
	fmt.Printf("d的类型为:[%T],d的值为:[%d]\n", d, d)

	e := -2147483648 //表示int32的最小值
	f := 4294967295  //表示uint32的最大值
	fmt.Printf("e的类型为:[%T],e的值为:[%d]\n", e, e)
	fmt.Printf("f的类型为:[%T],f的值为:[%d]\n", f, f)

	g := -9223372036854775808 //表示int64的最小值
	/*
		温馨提示:
			下面这条注释语句会编译报错的，由于默认使用自动推导类型创建整数型均为int类型，因此无法表示uint64类型的最大值
	*/
	//h := 18446744073709551615
	var h uint = 18446744073709551615 //我们想要使用uint64最大值需要声明数据类型为uint
	fmt.Printf("g的类型为:[%T],g的值为:[%d]\n", g, g)
	fmt.Printf("h的类型为:[%T],h的值为:[%d]\n", h, h)
}
